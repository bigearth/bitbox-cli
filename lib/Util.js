"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _axios = require("axios");

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Util = function () {
  function Util(config, baseURL) {
    _classCallCheck(this, Util);

    this.config = config;
    this.baseURL = baseURL;
  }

  _createClass(Util, [{
    key: "createMultisig",
    value: function createMultisig(required, address) {
      // The createmultisig RPC creates a P2SH multi-signature address.

      // Parameter #1—the number of signatures required
      // The minimum (m) number of signatures required to spend this m-of-n multisig script

      // Parameter #2—the full public keys, or addresses for known public keys

      // An array of strings with each string being a public key or address
      // or
      // A public key against which signatures will be checked. If wallet support is enabled, this may be a P2PKH address belonging to the wallet—the corresponding public key will be substituted.
      // There must be at least as many keys as specified by the Required parameter, and there may be more keys

      // Result—P2SH address and hex-encoded redeem script

      return _axios2.default.post(this.baseURL, {
        jsonrpc: "1.0",
        id: "createmultisig",
        method: "createmultisig",
        params: [required, address]
      }, {
        auth: {
          username: this.config.username,
          password: this.config.password
        }
      }).then(function (response) {
        return response.data.result;
      }).catch(function (error) {
        return JSON.stringify(error.response.data.error.message);
      });
    }
  }, {
    key: "signMessageWithPrivKey",
    value: function signMessageWithPrivKey(privkey, message) {
      // Sign a message with the private key of an address

      // Arguments:
      // 1. "privkey"         (string, required) The private key to sign the message with.
      // 2. "message"         (string, required) The message to create a signature of.

      // Result:
      // "signature"          (string) The signature of the message encoded in base 64

      var params = [];
      if (privkey) {
        params.push(privkey);
      }

      if (message) {
        params.push(message);
      }

      return _axios2.default.post(this.baseURL, {
        jsonrpc: "1.0",
        id: "signmessagewithprivkey",
        method: "signmessagewithprivkey",
        params: params
      }, {
        auth: {
          username: this.config.username,
          password: this.config.password
        }
      }).then(function (response) {
        return response.data.result;
      }).catch(function (error) {
        return JSON.stringify(error.response.data.error.message);
      });
    }
  }, {
    key: "validateAddress",
    value: function validateAddress(address) {
      // Return information about the given bitcoin address.
      //
      // Arguments:
      // 1. "address"     (string, required) The bitcoin address to validate
      //
      // Result:
      // {
      //   "isvalid" : true|false,       (boolean) If the address is valid or not. If not, this is the only property returned.
      //   "address" : "address", (string) The bitcoin address validated
      //   "scriptPubKey" : "hex",       (string) The hex encoded scriptPubKey generated by the address
      //   "ismine" : true|false,        (boolean) If the address is yours or not
      //   "iswatchonly" : true|false,   (boolean) If the address is watchonly
      //   "isscript" : true|false,      (boolean) If the key is a script
      //   "pubkey" : "publickeyhex",    (string) The hex value of the raw public key
      //   "iscompressed" : true|false,  (boolean) If the address is compressed
      //   "account" : "account"         (string) DEPRECATED. The account associated with the address, "" is the default account
      //   "timestamp" : timestamp,        (number, optional) The creation time of the key if available in seconds since epoch (Jan 1 1970 GMT)
      //   "hdkeypath" : "keypath"       (string, optional) The HD keypath if the key is HD and available
      //   "hdmasterkeyid" : "<hash160>" (string, optional) The Hash160 of the HD master pubkey
      // }
      return _axios2.default.get(this.baseURL + "util/validateAddress/" + address).then(function (response) {
        return response.data.result;
      }).catch(function (error) {
        return JSON.stringify(error.response.data.error.message);
      });
    }
  }, {
    key: "verifyMessage",
    value: function verifyMessage(address, signature, message) {
      // Verify a signed message

      // Arguments:
      // 1. "address"         (string, required) The bitcoin address to use for the signature.
      // 2. "signature"       (string, required) The signature provided by the signer in base 64 encoding (see signmessage).
      // 3. "message"         (string, required) The message that was signed.

      // Result:
      // true|false   (boolean) If the signature is verified or not.

      return _axios2.default.get(this.baseURL + "util/verifyMessage/" + address + "/" + signature + "/" + message).then(function (response) {
        return response.data.result;
      }).catch(function (error) {
        return JSON.stringify(error.response.data.error.message);
      });
    }
  }]);

  return Util;
}();

exports.default = Util;